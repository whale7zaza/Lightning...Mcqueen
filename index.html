<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sperm swine  </title>
  <style>
    :root{
      --bg:#cce2fa; --card:#ffffff; --text:#1f2937; --muted:#6b7280;
      --primary:#3b82f6; --primary-600:#2563eb; --primary-50:#eff6ff;
      --border:#dbeafe; --table-head:#1d4ed8;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{padding:28px 20px 10px;text-align:center}
    h1{margin:0 0 6px;font-size:26px;color:var(--table-head)}
    .subtitle{margin:0;color:var(--muted)}
    main{max-width:1200px;margin:0 auto;padding:16px;display:grid;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.06)}
    h2{margin:0 0 8px;color:var(--table-head);font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{border:1px solid var(--primary-600);background:linear-gradient(180deg,var(--primary),var(--primary-600));color:#fff;
      padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600}
    .btn.ghost{background:var(--primary-50);border-color:var(--border);color:var(--text)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .panel{background:var(--primary-50);border:1px dashed var(--border);border-radius:12px;padding:8px}
    video,canvas{max-width:100%;border-radius:10px;background:#000}
    .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-top:10px}
    .stat{background:#f8fafc;border:1px solid var(--border);border-radius:12px;padding:12px}
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-size:20px;font-variant-numeric:tabular-nums}
    .qc{margin-top:8px;padding:10px;background:#f0f9ff;border:1px solid var(--border);border-radius:12px}
    .ok{color:#15803d} .warn{color:#b45309} .bad{color:#b91c1c}
    .muted{color:var(--muted)}
    footer{text-align:center;padding:14px;color:var(--muted)}
    details{margin-top:10px}
    details > summary{cursor:pointer; color:var(--table-head); font-weight:600}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px; margin-top:8px}
    label{display:grid;gap:6px;font-size:13px;color:var(--muted)}
    input,select{background:#fff;border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px}
  </style>
</head>
<body>
  <header>
    <h1>Lightning Mcqueen</h1>
    <p class="subtitle">ใช้เพื่อตรวจสอบคุณภาพของน้ำเชื้อ เพื่อให้ได้การประสิทธิภาพที่ดีที่สุด</p>
  </header>

  <main>
    <section class="card">
      <h2>อัปโหลดคลิป</h2>
      <div class="row">
        <label class="btn ghost" for="file">เลือกไฟล์วิดีโอ (MP4/WEBM)</label>
        <input type="file" id="file" accept="video/*" style="display:none">
        <button id="btnStart" class="btn" disabled>เริ่มวิเคราะห์</button>
        <button id="btnStop" class="btn ghost" disabled>หยุด</button>
      </div>
      <details>
        <summary>ตัวเลือกขั้นสูง (เพิ่มเฟรมที่ประมวลผล)</summary>
        <div class="controls">
          <label>เป้าหมาย FPS ในการประมวลผล
            <input id="fpsTarget" type="number" value="25" step="1" min="5" max="60">
          </label>
          <label>ลดขนาดเพื่อประมวลผล (Downscale)
            <select id="downscale">
              <option value="1">1.0x (เต็มความละเอียด)</option>
              <option value="0.75">0.75x</option>
              <option value="0.5" selected>0.5x (แนะนำ)</option>
              <option value="0.35">0.35x</option>
              <option value="0.25">0.25x</option>
            </select>
          </label>
        </div>
        <small class="muted">* ลดขนาดการประมวลผลจะช่วยให้เฟรม/วินาทีสูงขึ้นมาก โดยใช้ภาพสำหรับคำนวณที่เล็กลง แล้วค่อยวาด overlay กลับบนภาพใหญ่</small>
      </details>
    </section>

    <section class="card">
      <h2>แสดงตัวอย่าง & ผลการวิเคราะห์</h2>
      <div class="panel">
        <div class="row" style="gap:12px">
          <video id="vid" controls muted style="flex:1"></video>
          <canvas id="canvas" style="flex:1"></canvas>
        </div>
      </div>

      <div class="stats">
        <div class="stat"><div class="label">เฟรมที่ประมวลผลสะสม</div><div id="sFrames" class="value">0</div></div>
        <div class="stat"><div class="label">อัตราเฟรมที่ประมวลผล (FPS)</div><div id="sProcFps" class="value">-</div></div>
        <div class="stat"><div class="label">% เคลื่อนที่ (Motility)</div><div id="sMot" class="value">-</div></div>
        <div class="stat"><div class="label">% มีชีวิต (ประมาณ)</div><div id="sVia" class="value">-</div></div>
        <div class="stat"><div class="label">VCL เฉลี่ย (µm/s)</div><div id="sVcl" class="value">-</div></div>
        <div class="stat"><div class="label">คะแนนคุณภาพ (0–100)</div><div id="sQual" class="value">-</div></div>
        <div class="stat"><div class="label">จำนวนวัตถุติดตาม</div><div id="sObjs" class="value">0</div></div>
      </div>
      <div id="qc" class="qc"></div>
    </section>
  </main>

  <footer>
    <small>Website For Chantanatrakul Farm</small>
  </footer>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  const $=(id)=>document.getElementById(id);
  let cvReady=false, processing=false;
  let prevGray=null, gray=null, diffMat=null, threshMat=null, kernel=null;
  const tracks=new Map(); let nextId=1;
  const frameStats=[]; // optional buffer
  let processedFrames=0;
  let procFps=0, fpsCounter=0, fpsLast=performance.now();

  const CFG={ umPerPx:0.3, threshold:25, minArea:8, vMin:20, vAliveMin:5, aliveWindow:20 };

  // Wait for CV
  (function waitCv(){ if(window.cv && cv.Mat){ cvReady=true; enableButtons(); } else setTimeout(waitCv,150); })();

  function enableButtons(){ if(cvReady && $('vid').src){ $('btnStart').disabled=false; $('btnStop').disabled=false; } }

  $('file').addEventListener('change', e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const vid=$('vid'); vid.src=URL.createObjectURL(f);
    vid.addEventListener('canplay', ()=>{ resizeCanvasToVideo(); enableButtons(); }, {once:true});
  });

  function resizeCanvasToVideo(){
    const vid=$('vid'), canvas=$('canvas');
    canvas.width=vid.videoWidth||640; canvas.height=vid.videoHeight||480;
    if (prevGray) { prevGray.delete(); prevGray=null; }
    if (gray) gray.delete(); if (diffMat) diffMat.delete(); if (threshMat) threshMat.delete();
    gray=new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    diffMat=new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    threshMat=new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    if (!kernel) kernel=cv.Mat.ones(3,3,cv.CV_8U);
  }

  function start(){
    if(!cvReady){ alert('ยังโหลด OpenCV.js ไม่เสร็จ'); return; }
    const vid=$('vid'); if(!vid.videoWidth){ alert('ยังไม่พร้อมเล่นวิดีโอ'); return; }
    tracks.clear(); nextId=1; frameStats.length=0; processedFrames=0; procFps=0; fpsCounter=0; fpsLast=performance.now();
    ['sFrames','sProcFps','sMot','sVia','sVcl','sQual','sObjs'].forEach(id=>$(id).textContent=(id==='sFrames')?'0':'-');
    $('qc').innerHTML=''; processing=true; vid.play();
    loop();
  }
  function stop(){ processing=false; $('vid').pause(); }

  function nearestTrack(cx,cy,maxDist=25){
    let bestId=null, bestD=maxDist; const now=performance.now();
    for(const [id,tr] of tracks){
      const dt=(now-tr.lastSeen)/1000; if(dt>1.0) continue;
      const d=Math.hypot(tr.x-cx,tr.y-cy); if(d<bestD){bestD=d; bestId=id;}
    }
    return bestId;
  }
  function updateTracks(dets, dt, umPerPx){
    const now=performance.now(); for(const [id,tr] of tracks){tr.seen=false;}
    for(const {cx,cy} of dets){
      const id=nearestTrack(cx,cy,30);
      if(id){
        const tr=tracks.get(id);
        const vx=(cx-tr.x)/dt*umPerPx, vy=(cy-tr.y)/dt*umPerPx;
        const speed=Math.hypot(vx,vy);
        tr.x=cx; tr.y=cy; tr.vx=vx; tr.vy=vy; tr.lastSeen=now; tr.seen=true;
        tr.spHist = tr.spHist || [];
        tr.spHist.push(speed); if(tr.spHist.length>CFG.aliveWindow) tr.spHist.shift();
      } else {
        tracks.set(nextId++, {x:cx,y:cy,lastSeen:now,vx:0,vy:0,seen:true,spHist:[0]});
      }
    }
    for(const [id,tr] of Array.from(tracks)){ if(!tr.seen && (now-tr.lastSeen)>1200) tracks.delete(id); }
  }

  // Offscreen canvas for faster processing
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d', { willReadFrequently: true });

  function loop(){
    const vid=$('vid'), canvas=$('canvas'), ctx=canvas.getContext('2d');
    let lastTime = performance.now();
    let acc = 0; // accumulator for target FPS

    const step=(now)=>{
      if(!processing) return;
      const dtAll = (now - lastTime)/1000; lastTime = now;
      acc += dtAll;

      const targetFps = Math.max(5, Math.min(60, parseFloat($('fpsTarget').value)||25));
      const frameInterval = 1/targetFps;

      // Only process when accumulator exceeds desired interval (frame skipping)
      if (acc >= frameInterval){
        acc -= frameInterval;

        // Downscale
        const scale = Math.max(0.25, Math.min(1, parseFloat($('downscale').value)||0.5));
        const w = Math.floor(canvas.width * scale), h = Math.floor(canvas.height * scale);
        if (off.width !== w || off.height !== h){ off.width = w; off.height = h; }

        // Draw current video frame to offscreen
        offCtx.drawImage(vid, 0, 0, w, h);
        const imgData = offCtx.getImageData(0, 0, w, h);
        const src = cv.matFromImageData(imgData); // CV_8UC4
        const rgba = new cv.Mat(); cv.cvtColor(src, rgba, cv.COLOR_RGBA2RGB); // CV_8UC3

        // Prepare small mats for processing
        const gSmall = new cv.Mat(); cv.cvtColor(rgba, gSmall, cv.COLOR_RGB2GRAY);
        const dSmall = new cv.Mat(); const tSmall = new cv.Mat();
        let pSmall = null;
        if (!prevGray){
          pSmall = gSmall.clone();
        } else {
          // resize prevGray (full-res) down to small for consistent diff
          pSmall = new cv.Mat();
          cv.resize(prevGray, pSmall, new cv.Size(w, h), 0, 0, cv.INTER_AREA);
        }

        cv.absdiff(gSmall, pSmall, dSmall);
        cv.threshold(dSmall, tSmall, CFG.threshold, 255, cv.THRESH_BINARY);
        const kernel = cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(tSmall, tSmall, cv.MORPH_OPEN, kernel);

        const contoursMV=new cv.MatVector(); const hierarchyM=new cv.Mat();
        cv.findContours(tSmall, contoursMV, hierarchyM, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        const dets=[];
        for(let i=0;i<contoursMV.size();i++){
          const c=contoursMV.get(i), area=cv.contourArea(c);
          if(area>=CFG.minArea){
            const m=cv.moments(c); if(m.m00!==0){
              // scale back to display coordinates
              dets.push({cx:(m.m10/m.m00)/scale, cy:(m.m01/m.m00)/scale});
            }
          }
          c.delete();
        }
        contoursMV.delete(); hierarchyM.delete();

        // Update tracks (use dt=frameInterval)
        updateTracks(dets, frameInterval, CFG.umPerPx);

        let moving=0,total=0,vSum=0, alive=0;
        for(const [id,tr] of tracks){
          total++; const speed=Math.hypot(tr.vx||0,tr.vy||0);
          if(speed>=CFG.vMin) moving++;
          if(isFinite(speed)) vSum+=speed;
          const hist=(tr.spHist||[]).slice().sort((a,b)=>a-b);
          const med = hist.length? (hist[Math.floor(hist.length/2)]) : 0;
          if(med >= CFG.vAliveMin) alive++;
        }
        const motPct= total? (moving/total*100):0;
        const vcl = total? (vSum/total):0;
        const viaPct= total? (alive/total*100):0;
        const vclNorm=Math.max(0,Math.min(100,vcl/40*100));
        const quality=0.4*motPct + 0.3*viaPct + 0.3*vclNorm;

        // Draw original frame to display canvas, then overlay
        ctx.drawImage(vid,0,0,canvas.width,canvas.height);
        ctx.lineWidth=2;
        for(const [id,tr] of tracks){
          const speed=Math.hypot(tr.vx||0,tr.vy||0);
          ctx.strokeStyle=speed>=CFG.vMin?'#16a34a':'#f59e0b';
          ctx.beginPath(); ctx.arc(tr.x, tr.y, 6, 0, Math.PI*2); ctx.stroke();
        }
        ctx.fillStyle='#ffffff'; ctx.font='14px ui-sans-serif';
        ctx.fillText(`motility≈ ${motPct.toFixed(0)}% | viability≈ ${viaPct.toFixed(0)}% | VCL≈ ${vcl.toFixed(0)} µm/s | qual≈ ${quality.toFixed(0)}`, 10, 20);

        // Update stats
        processedFrames++; fpsCounter++;
        $('sFrames').textContent=String(processedFrames);
        $('sMot').textContent=`${motPct.toFixed(0)}%`;
        $('sVia').textContent=`${viaPct.toFixed(0)}%`;
        $('sVcl').textContent=`${vcl.toFixed(0)}`;
        $('sQual').textContent=`${quality.toFixed(0)}`;
        $('sObjs').textContent=String(total);

        // Update live FPS every 500 ms
        const nowMs = performance.now();
        if (nowMs - fpsLast >= 500){
          procFps = Math.round(fpsCounter * 1000 / (nowMs - fpsLast));
          $('sProcFps').textContent = String(procFps);
          fpsCounter = 0; fpsLast = nowMs;
        }

        // Update prevGray at full-res so that resize each loop works
        // Create full-res gray from current video frame for next iteration
        const dispCtx = canvas.getContext('2d');
        const dispImg = dispCtx.getImageData(0,0,canvas.width,canvas.height);
        const dispMat = cv.matFromImageData(dispImg);
        const dispRGB = new cv.Mat(); cv.cvtColor(dispMat, dispRGB, cv.COLOR_RGBA2RGB);
        const dispGray = new cv.Mat(); cv.cvtColor(dispRGB, dispGray, cv.COLOR_RGB2GRAY);
        if (prevGray) prevGray.delete();
        prevGray = dispGray;
        dispRGB.delete(); dispMat.delete();

        // Cleanup small mats
        src.delete(); rgba.delete(); gSmall.delete(); dSmall.delete(); tSmall.delete(); pSmall.delete(); kernel.delete();
      }

      requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  $('btnStart').addEventListener('click', start);
  $('btnStop').addEventListener('click', stop);

  // Keep timers from throttling: if tab becomes hidden, we warn user
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden && processing){
      console.log('Tab hidden: browser may throttle processing FPS');
    }
  });
  </script>
</body>
</html>
